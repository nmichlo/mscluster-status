package main

import (
	"errors"
	"fmt"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/bwmarrin/discordgo"
	"github.com/melbahja/goph"
	"golang.org/x/crypto/ssh"
	"log"
	"math"
	"os"
	"strconv"
	"strings"
	"time"
)

/* ======================================================================== */
/* ENVIRONMENT                                                              */
/* ======================================================================== */

func getEnvStr(key string) string {
	value, found := os.LookupEnv(key)
	if !found {
		log.Fatalf("environment variable: '%s' is required!", key)
	}
	return value
}

func getEnvStrOrFallback(key string, fallback string) string {
	value, found := os.LookupEnv(key)
	if !found {
		return fallback
	}
	return value
}

func getEnvInt(key string) int {
	value, found := os.LookupEnv(key)
	if !found {
		log.Fatalf("environment variable: '%s' is required!", key)
	}
	converted, err := strconv.Atoi(value)
	if err != nil {
		log.Fatalf("environment variable: '%s', with value: '%s', could not be converted to an integer!", key, value)
	}
	return converted
}

func getEnvIntOrFallback(key string, fallback int) int {
	value, found := os.LookupEnv(key)
	if !found {
		return fallback
	}
	converted, err := strconv.Atoi(value)
	if err != nil {
		log.Fatalf("environment variable: '%s', with value: '%s', could not be converted to an integer!", key, value)
	}
	return converted
}

/* ======================================================================== */
/* HELPER                                                                   */
/* ======================================================================== */

func where(isEnabled bool, enabled string, disabled string) string {
	if isEnabled {
		return enabled
	} else {
		return disabled
	}
}

/* ======================================================================== */
/* POLL                                                                     */
/* ======================================================================== */

func pollClusterStatus(client *goph.Client, retries int) (bool, string, time.Time) {
	pollTime := time.Now()
	pollErr := "unknown error"
	// try polling multiple times, if we fail each time then send a message!
	for i := 0; i < retries; i++ {
		pollTime = time.Now()
		// try poll for the cluster status
		out, err := client.Run("sinfo --summarize")
		// we failed to poll the cluster status
		if err != nil {
			pollErr = err.Error()
		}
		// we successfully polled the cluster status
		return true, string(out), pollTime
	}
	return false, pollErr, pollTime
}

type PartitionInfo struct {
	name     string
	status   string
	limit    string
	nodelist string
	alloc    string
	idle     string
	down     string
	total    string
}

const REQUIRED_SINFO_HEADING = "PARTITION AVAIL  TIMELIMIT   NODES(A/I/O/T)  NODELIST"

// Parse a string generated by the SLURM sinfo command
// EXAMPLE:
//     PARTITION AVAIL  TIMELIMIT   NODES(A/I/O/T)  NODELIST
//     batch*       up 3-00:00:00       22/0/26/48  mscluster[11-58]
//     biggpu       up 3-00:00:00          1/2/0/3  mscluster[10,59-60]
//     stampede     up 3-00:00:00        35/1/4/40  mscluster[61-100]
func _parseSinfoPartitions(sinfoSummaryString string) ([]PartitionInfo, error) {
	// parse the individual lines that actually contain content
	var lines []string
	for _, line := range strings.Split(sinfoSummaryString, "\n") {
		line = strings.TrimSpace(line)
		if line != "" {
			lines = append(lines, line)
		}
	}
	// check heading
	if len(lines) < 1 || lines[0] != REQUIRED_SINFO_HEADING {
		return []PartitionInfo{}, errors.New("invalid sinfo heading")
	}
	// parse the statuses
	var partitions []PartitionInfo
	for _, line := range lines[1:] {
		// parse components
		var segments []string
		for _, segment := range strings.Split(line, " ") {
			segment = strings.TrimSpace(segment)
			if segment != "" {
				segments = append(segments, segment)
			}
		}
		// check segments
		if len(segments) != 5 {
			return []PartitionInfo{}, errors.New("sinfo row must be of format: `PARTITION AVAIL TIMELIMIT NODES(A/I/O/T) NODELIST`")
		}
		// parse nodes
		aiotStrings := strings.Split(segments[3], "/")
		// check nodes
		if len(aiotStrings) != 4 {
			return []PartitionInfo{}, errors.New("node count must be of format: `A/I/O/T`")
		}
		for _, countString := range aiotStrings {
			_, err := strconv.Atoi(countString)
			if err != nil {
				return []PartitionInfo{}, errors.New("could not parse node count, not an integer")
			}
		}
		// construct and append the value
		partitions = append(partitions, PartitionInfo{
			name:     strings.TrimRight(segments[0], "*"), // partition
			status:   segments[1],                         // avail
			limit:    segments[2],                         // timelimit
			nodelist: segments[4],                         // nodelist
			alloc:    aiotStrings[0],                      // A
			idle:     aiotStrings[1],                      // I
			down:     aiotStrings[2],                      // O
			total:    aiotStrings[3],                      // T
		})
	}
	// generate the formatted table
	return partitions, nil
}

func _maxPartitionsLen(partitions []PartitionInfo, lenFn func(partition PartitionInfo) int) int {
	max := lenFn(partitions[0])
	for i := 1; i < len(partitions); i += 1 {
		val := lenFn(partitions[i])
		if val > max {
			max = val
		}
	}
	return max
}

func prettifySinfoPartitions(sinfoSummaryString string) (string, error) {
	// parse the partitions
	partitions, err := _parseSinfoPartitions(sinfoSummaryString)
	if err != nil {
		return sinfoSummaryString, errors.New(fmt.Sprintf("failed to parse sinfo string, got: %s", err.Error()))
	}
	// get the maximum lengths of each column
	lenName := _maxPartitionsLen(partitions, func(partition PartitionInfo) int { return len(partition.name) })
	lenIdle := _maxPartitionsLen(partitions, func(partition PartitionInfo) int { return len(partition.idle) })
	lenAllo := _maxPartitionsLen(partitions, func(partition PartitionInfo) int { return len(partition.alloc) })
	lenDown := _maxPartitionsLen(partitions, func(partition PartitionInfo) int { return len(partition.down) })
	lenTota := _maxPartitionsLen(partitions, func(partition PartitionInfo) int { return len(partition.total) })
	fmtStr := fmt.Sprintf("%%-%ds %%%ds|%%%ds|%%%ds|%%%ds  # [✓|✗|☠|⅀] (%%s)", lenName+1, lenIdle, lenAllo, lenDown, lenTota)
	// format the output string
	var lines []string
	for _, partition := range partitions {
		lines = append(lines, fmt.Sprintf(fmtStr, partition.name+":", partition.idle, partition.alloc, partition.down, partition.total, partition.status))
	}
	return strings.Join(lines, "\n"), nil
}

/* ======================================================================== */
/* FORMAT TIME                                                              */
/* ======================================================================== */

func _divMod(value int, modulo int) (int, int) {
	return value / modulo, value % modulo
}

func _fmtTimeDurationUpdate(i int, segments []string, v int, idx int, unit string) (int, []string) {
	if (v > 0 || i > idx) && (i < idx+2) {
		if i <= idx {
			i = idx
		}
		segments = append(segments, fmt.Sprintf("%d%s", v, unit))
	}
	return i, segments
}

func fmtTimeDuration(delta time.Duration, sep string) string {
	s := int(math.Abs(delta.Seconds()))
	y, s := _divMod(s, 60*60*24*365)
	d, s := _divMod(s, 60*60*24)
	h, s := _divMod(s, 60*60)
	m, s := _divMod(s, 60)
	i, segments := 0, []string{}
	i, segments = _fmtTimeDurationUpdate(i, segments, y, 5, "y")
	i, segments = _fmtTimeDurationUpdate(i, segments, d, 4, "d")
	i, segments = _fmtTimeDurationUpdate(i, segments, h, 3, "h")
	i, segments = _fmtTimeDurationUpdate(i, segments, m, 2, "m")
	i, segments = _fmtTimeDurationUpdate(i, segments, s, 1, "s")
	sign := ""
	if delta.Seconds() < 0 {
		sign = "-"
	}
	return sign + strings.Join(segments, sep)
}

/* ======================================================================== */
/* SSH                                                                      */
/* ======================================================================== */

func NewSshSession(user string, addr string, auth goph.Auth, port int) (client *goph.Client, err error) {
	// TODO: this is a hack for AWS lambda, should not be used for PROD,
	//      but AWS Lambda does not set $HOME or have a .ssh folder
	callback := ssh.InsecureIgnoreHostKey()
	if _, found := os.LookupEnv("HOME"); found {
		callback, err = goph.DefaultKnownHosts()
	} else {
		log.Println("using insecure ssh ignore host key for aws lambda")
	}
	if err != nil {
		return
	}
	client, err = goph.NewConn(&goph.Config{
		User:     user,
		Addr:     addr,
		Port:     uint(port),
		Auth:     auth,
		Timeout:  goph.DefaultTimeout,
		Callback: callback,
	})
	return
}

/* ======================================================================== */
/* CORE                                                                     */
/* ======================================================================== */

func pollAndReport() {
	// debug
	DEBUG_SCRIPT := getEnvIntOrFallback("DEBUG_SCRIPT", 1) // debug if != 0

	// ssh: authentication details
	CLUSTER_HOST := getEnvStr("CLUSTER_HOST")
	CLUSTER_USER := getEnvStr("CLUSTER_USER")
	CLUSTER_PORT := getEnvIntOrFallback("CLUSTER_PORT", 22)
	CLUSTER_PASSWORD := getEnvStr("CLUSTER_PASSWORD")

	// ssh: connection details
	CLUSTER_CONNECT_RETRIES := getEnvIntOrFallback("CLUSTER_CONNECT_RETRIES", 5)

	// discord: get the bot token & channel to modify
	DISCORD_BOT_TOKEN := getEnvStr("DISCORD_BOT_TOKEN")
	_DISCORD_BOT_CHANNEL_ID := getEnvStrOrFallback("DISCORD_BOT_CHANNEL_ID", "")
	_DISCORD_BOT_CHANNEL_ID_DEBUG := getEnvStrOrFallback("DISCORD_BOT_CHANNEL_ID_DEBUG", "")
	DISCORD_BOT_WEBHOOK_NAME := getEnvStrOrFallback("DISCORD_BOT_WEBHOOK_NAME", "[BOT] Cluster Status Hook [DO-NOT-EDIT]")
	DISCORD_BOT_RETRIES := getEnvIntOrFallback("DISCORD_BOT_RETRIES", 3)
	DISCORD_TIME_LOCATION := getEnvStrOrFallback("DISCORD_TIME_LOCATION", "Africa/Johannesburg")

	// discord: get the information to display
	_DISCORD_USER_ON := getEnvStrOrFallback("DISCORD_USER_ON", "Cluster Status")
	_DISCORD_USER_OFF := getEnvStrOrFallback("DISCORD_USER_OFF", "Cluster Status")
	_DISCORD_IMG_ON := getEnvStrOrFallback("DISCORD_IMG_ON", "https://raw.githubusercontent.com/nmichlo/uploads/main/imgs/avatar/cat_happy.jpg")
	_DISCORD_IMG_OFF := getEnvStrOrFallback("DISCORD_IMG_OFF", "https://raw.githubusercontent.com/nmichlo/uploads/main/imgs/avatar/cat_glum.jpg")
	_DISCORD_EMOJI_ON := getEnvStrOrFallback("DISCORD_EMOJI_ON", "🌞")
	_DISCORD_EMOJI_OFF := getEnvStrOrFallback("DISCORD_EMOJI_OFF", "⛈")
	_DISCORD_CHANNEL_NAME_ON := getEnvStrOrFallback("DISCORD_CHANNEL_NAME_ON", "cluster-status-🌞")
	_DISCORD_CHANNEL_NAME_OFF := getEnvStrOrFallback("DISCORD_CHANNEL_NAME_OFF", "cluster-status-⛈")

	// check variables
	timeLocation, err := time.LoadLocation(DISCORD_TIME_LOCATION)
	if err != nil {
		log.Fatal(err)
	}

	// - get debug settings
	var discordChannelId string
	if DEBUG_SCRIPT != 0 {
		discordChannelId = _DISCORD_BOT_CHANNEL_ID_DEBUG
		if discordChannelId == "" {
			log.Fatalf("DISCORD_BOT_CHANNEL_ID_DEBUG must be specified")
		}
	} else {
		discordChannelId = _DISCORD_BOT_CHANNEL_ID
		if discordChannelId == "" {
			log.Fatalf("DISCORD_BOT_CHANNEL_ID must be specified")
		}
	}

	/* ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */
	/* SSH                                           */
	/* ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */

	// 1. connect to cluster
	client, err := NewSshSession(CLUSTER_USER, CLUSTER_HOST, goph.Password(CLUSTER_PASSWORD), CLUSTER_PORT)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Close()

	// 2. poll the cluster status
	log.Println("polling cluster:")
	pollSuccess, pollString, pollTime := pollClusterStatus(client, CLUSTER_CONNECT_RETRIES)
	log.Println("polled cluster: success='%s', msg='%s', time='%s'", pollSuccess, pollString, pollTime)

	// 3. update variables based on status
	botUser := where(pollSuccess, _DISCORD_USER_ON, _DISCORD_USER_OFF)
	botImg := where(pollSuccess, _DISCORD_IMG_ON, _DISCORD_IMG_OFF)
	botEmoji := where(pollSuccess, _DISCORD_EMOJI_ON, _DISCORD_EMOJI_OFF)
	botChannelName := where(pollSuccess, _DISCORD_CHANNEL_NAME_ON, _DISCORD_CHANNEL_NAME_OFF)
	botStatus := where(pollSuccess, "ONLINE", "OFFLINE")

	// - prettify the sinfo string
	if pollSuccess {
		pollString, err = prettifySinfoPartitions(pollString)
		if err != nil {
			log.Printf("failed to prettify sinfo string: %s", err.Error())
		}
	}

	// - prepend test string to channel name
	if DEBUG_SCRIPT != 0 {
		botChannelName = "test-" + botChannelName
	}

	/* ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */
	/* Discord                                       */
	/* ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */

	// check for existing status message
	// a) if not (existing status message): post status
	// b) if (existing status message) and (status matches): update message
	// c) if (existing status message) and not (status matches): post new message

	// 1. start new discord session
	session, err := discordgo.New("Bot " + DISCORD_BOT_TOKEN)
	session.MaxRestRetries = DISCORD_BOT_RETRIES
	if err != nil {
		log.Fatal(err)
	}
	defer session.Close()

	/* --- CHANNEL --- */

	// - load the channel, and make sure no errors occur doing this!
	log.Println("- getting channel")
	channel, err := session.Channel(discordChannelId)
	if err != nil {
		log.Fatal(err)
	}
	if channel.Type != discordgo.ChannelTypeGuildText {
		log.Fatalf("The discord channel: %s is not a text channel!", channel.Name)
	}

	// - adjust the channel name if it is not correct
	if channel.Name != botChannelName {
		log.Printf("- editing channel name: '%s'\n", botChannelName)
		_, err := session.ChannelEdit(discordChannelId, botChannelName)
		if err != nil {
			log.Printf("- editing channel name failed... %s", err.Error())
		}
	}

	// - send a message
	// discord.ChannelMessageSend(DISCORD_BOT_CHANNEL_ID, "failed to edit channel name")

	/* --- WEBHOOK --- */

	// get webhook to send message
	log.Println("- getting webhooks")
	webhooks, err := session.ChannelWebhooks(discordChannelId)
	if err != nil {
		log.Fatal(err)
	}
	// - linear search for webhook, otherwise create it!
	var webhook *discordgo.Webhook = nil
	for _, w := range webhooks {
		if w.Name == DISCORD_BOT_WEBHOOK_NAME {
			webhook = w
			log.Printf("- found webhook: '%s'", w.Name)
			break
		}
	}
	// - create webhook if it does not exist
	if webhook == nil {
		log.Printf("- creating webhook: '%s'", DISCORD_BOT_WEBHOOK_NAME)
		webhook, err = session.WebhookCreate(discordChannelId, DISCORD_BOT_WEBHOOK_NAME, "")
		if err != nil {
			log.Fatalf("* failed to create webhook, please meanually create the webhook with the name: '%s' on the channel: '%s'", DISCORD_BOT_WEBHOOK_NAME, botChannelName)
		}
	}

	/* --- MSG --- */

	// check if we need to update the last message
	var lastMsg *discordgo.Message = nil
	if channel.LastMessageID == "" {
		log.Println("- no last message found, will send a new message")
	} else {
		lastMsg, err = session.ChannelMessage(discordChannelId, channel.LastMessageID)
		if lastMsg.Author.Bot && (lastMsg.Author.ID == webhook.ID) && strings.Contains(lastMsg.Content, botEmoji) {
			log.Println("- last message found, will update it")
		} else {
			log.Println("- last message found, but it is invalid, will send a new message: `{repr(last_msg.author.bot)} is False` or `{repr(last_msg.author.id)} != {repr(webhook.id)}` or {repr(bot_emoji)} not in {repr(last_msg.content)}")
			lastMsg = nil
		}
	}

	// get poll & msg creation times, then compute delta
	pollTime = pollTime.In(timeLocation)
	msgTime := pollTime
	if lastMsg != nil {
		msgTime = lastMsg.Timestamp.In(timeLocation)
	}

	// create the message
	pollTimeStr := pollTime.Format("**2006-01-02 15:04** (-0700)")
	elapsedTimeStr := fmtTimeDuration(pollTime.Sub(msgTime), " ")
	msgContent := fmt.Sprintf("%s **%s**  |  Duration: **%s**  |  Last Poll: %s\n```yaml\n%s\n```", botEmoji, botStatus, elapsedTimeStr, pollTimeStr, pollString)

	// if the last message is not valid, or it is not the same, send a new one:
	if lastMsg != nil {
		log.Printf("- editing last message:\n%s", msgContent)
		_, err = session.WebhookMessageEdit(webhook.ID, webhook.Token, lastMsg.ID, &discordgo.WebhookEdit{
			Content: msgContent,
		})
		if err != nil {
			log.Fatal(err)
		}
	} else {
		log.Printf("- sending new message:\n%s", msgContent)
		_, err = session.WebhookExecute(webhook.ID, webhook.Token, true, &discordgo.WebhookParams{
			Content:   msgContent,
			Username:  botUser,
			AvatarURL: botImg,
		})
		if err != nil {
			log.Fatal(err)
		}
	}
	/* --- DONE --- */

	/* ~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ */
}

/* ======================================================================== */
/* MAIN                                                                     */
/* ======================================================================== */

func fnLambda() (string, error) {
	// run our polling script
	pollAndReport()
	// return a success result
	return "success", nil
}

func fnMain() {
	pollAndReport()
}

func main() {
	// Make the handler available for Remote Procedure Call by AWS Lambda
	if _, found := os.LookupEnv("_LAMBDA_SERVER_PORT"); found {
		lambda.Start(fnLambda)
	} else {
		fnMain()
	}
}

/* ======================================================================== */
/* END                                                                      */
/* ======================================================================== */
